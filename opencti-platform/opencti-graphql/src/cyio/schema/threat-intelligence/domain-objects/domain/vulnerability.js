import { UserInputError } from 'apollo-server-errors';
import { logApp } from '../../../../../config/conf.js';
import {
  compareValues,
  filterValues,
  updateQuery,
  checkIfValidUUID,
  validateEnumValue,
  populateNestedDefinitions,
  processNestedDefinitions,
} from '../../../utils.js';
import { selectObjectIriByIdQuery, sanitizeInputFields } from '../../../global/global-utils.js';
import {
  getReducer,
  generateVulnerabilityId,
  getVulnerabilityIri,
  singularizeVulnerabilitySchema,
  vulnerabilityPredicateMap,
  selectVulnerabilityQuery,
  selectAllVulnerabilitiesQuery,
  insertVulnerabilityQuery,
  deleteVulnerabilityByIriQuery,
  selectVulnerabilityByIriQuery,
  attachToVulnerabilityQuery,
  detachFromVulnerabilityQuery,
} from '../schema/sparql/vulnerability.js';
import { createMetric, deleteMetricByIri } from './metric.js';
import { createAffectedProduct, deleteAffectedProductByIri } from './affectedProduct.js';
import { createVulnerabilityImpact, deleteVulnerabilityImpactByIri } from './vulnerabilityImpact.js';
import { createProblemType, deleteProblemTypeByIri } from './problemType.js';
import { createTaxonomyEntry, deleteTaxonomyEntryByIri } from './taxonomyEntry.js';
import { createCredit, deleteCreditByIri } from './credit.js';
import { createTimelineEntry, deleteTimelineEntryByIri } from './timelineEntry.js';
import { createVulnerabilitySource, deleteVulnerabilitySourceByIri } from './vulnerabilitySource.js';
import { createReference, deleteReferenceByIri } from './reference.js';
import { createExternalReference, deleteExternalReferenceByIri } from '../../../global/domain/externalReference.js';


export const findVulnerabilityById = async (id, dbName, dataSources, select) => {
  // ensure the id is a valid UUID
  if (!checkIfValidUUID(id)) throw new UserInputError(`Invalid identifier: ${id}`, {identifier: `${id}`});

  let iri = getVulnerabilityIri(id);
  return findVulnerabilityByIri(iri, dbName, dataSources, select);
};

export const findVulnerabilityByIri = async (iri, dbName, dataSources, select) => {
  if (!select.includes('id')) select.push('id');
  if (!select.includes('entity_type')) select.push('entity_type');
  
  let response;
  try {
    const sparqlQuery = selectVulnerabilityByIriQuery(iri, select);
    response = await dataSources.Stardog.queryById({
      dbName,
      sparqlQuery,
      queryId: "Select Vulnerability",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    logApp.error(e);
    throw e
  }
  
  if (response === undefined || response === null || response.length === 0) return null;
  let vulnerability = response[0];

  // Determine display name
  if (select.includes('display_name')) {
    if (vulnerability.hasOwnProperty('cisa_vulnerability_name')) {
      let display_name = `${vulnerability.vulnerability_id}: ${vulnerability.cisa_vulnerability_name}`;
      vulnerability.display_name = display_name.trim();
    } else if (vulnerability.hasOwnProperty('title')) {
      let display_name = `${vulnerability.vulnerability_id}: ${vulnerability.title}`;
      vulnerability.display_name = display_name.trim();
    }else {
      vulnerability.display_name = vulnerability.vulnerability_id;
    }
  }

  const reducer = getReducer("VULNERABILITY");
  return reducer(vulnerability);
};

export const findAllVulnerabilities = async ( parent, args, dbName, dataSources, select ) => {
  let response;
  try {
    const sparqlQuery = selectAllVulnerabilitiesQuery(select, args, parent); 
    response = await dataSources.Stardog.queryAll({
      dbName: dbName,
      sparqlQuery,
      queryId: "Select List of Vulnerabilities",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    logApp.error(e);
    throw e
  }

  // no results found
  if (response === undefined || response.length === 0) return null;

  // if no matching results, then return null
  if (Array.isArray(response) && response.length < 1) return null;

  const edges = [];
  const reducer = getReducer("VULNERABILITY");
  let skipCount = 0,filterCount = 0, resultCount = 0, limit, offset, limitSize, offsetSize;
  limitSize = limit = (args.first === undefined ? response.length : args.first) ;
  offsetSize = offset = (args.offset === undefined ? 0 : args.offset) ;

  if (select.includes('display_name')) {
    for (let vulnerability of response) {
      if (vulnerability.hasOwnProperty('cisa_vulnerability_name')) {
        let display_name = `${vulnerability.vulnerability_id}: ${vulnerability.cisa_vulnerability_name}`;
        vulnerability.display_name = display_name.trim();
      } else if (vulnerability.hasOwnProperty('title')) {
        let display_name = `${vulnerability.vulnerability_id}: ${vulnerability.title}`;
        vulnerability.display_name = display_name.trim();
      } else {
        vulnerability.display_name = vulnerability.vulnerability_id;
      }
    }
  }

  let resultList ;
  if (args.orderedBy !== undefined ) {
    resultList = response.sort(compareValues(args.orderedBy, args.orderMode ));
  } else {
    resultList = response;
  }

  // return null if offset value beyond number of results items
  if (offset > resultList.length) return null;

  // for each result in the result set
  for (let resultItem of resultList) {
    // skip down past the offset
    if (offset) {
      offset--
      continue
    }

    // filter out non-matching entries if a filter is to be applied
    if ('filters' in args && args.filters != null && args.filters.length > 0) {
      if (!filterValues(resultItem, args.filters, args.filterMode) ) {
        continue
      }
      filterCount++;
    }

    // if haven't reached limit to be returned
    if (limit) {
      let edge = {
        cursor: resultItem.iri,
        node: reducer(resultItem),
      }
      edges.push(edge)
      limit--;
      if (limit === 0) break;
    }
  }

  // check if there is data to be returned
  if (edges.length === 0 ) return null;
  
  let hasNextPage = false, hasPreviousPage = false;
  resultCount = resultList.length - skipCount;
  
  if (edges.length < resultCount) {
    if (edges.length === limitSize && filterCount <= limitSize ) {
      hasNextPage = true;
      if (offsetSize > 0) hasPreviousPage = true;
    }
    if (edges.length <= limitSize) {
      if (filterCount !== edges.length) hasNextPage = true;
      if (filterCount > 0 && offsetSize > 0) hasPreviousPage = true;
    }
  }
  return {
    pageInfo: {
      startCursor: edges[0].cursor,
      endCursor: edges[edges.length-1].cursor,
      hasNextPage: (hasNextPage ),
      hasPreviousPage: (hasPreviousPage),
      globalCount: resultCount,
    },
    edges: edges,
  }
};

export const createVulnerability = async (input, dbName, dataSources, select) => {
  // remove any empty fields or arrays
  sanitizeInputFields(input);

  // check if a vulnerability with this same id exists
  let checkId = generateVulnerabilityId( input );
  // ensure the id is a valid UUID
  if (!checkIfValidUUID(checkId)) {
    throw new UserInputError( `Invalid identifier: ${checkId}`, {identifier: `${checkId}`});
  }
  // check if an information system with this same id exists
  let existSelect = ['id','entity_type']
  let infoSys = await findVulnerabilityById(checkId, dbName, dataSources, existSelect);
  if ( infoSys != undefined && infoSys != null) {
    throw new UserInputError(`Cannot create vulnerability as entity ${checkId} already exists`, {identifier: `${checkId}`});
  }

  // Handle where a timestamp is passed instead of a date
  if (input.cisa_exploit_add !== undefined && input.cisa_exploit_add.length > 0) {
    if (input.cisa_exploit_add.indexOf('T') > -1 ) input.cisa_exploit_add = input.cisa_exploit_add.substr(0,input.cisa_exploit_add.indexOf('T'));
  }
  if (input.cisa_action_due !== undefined && input.cisa_action_due.length > 0) {
    if (input.cisa_action_due.indexOf('T') > -1 ) input.cisa_action_due = input.cisa_action_due.substr(0,input.cisa_action_due.indexOf('T'));
  }
  // Need to escape contents, remove explicit newlines, and collapse multiple what spaces.
  if (input.description !== undefined ) {
    input.description = input.description.replace(/\s+/g, ' ')
                                        .replace(/\n/g, '\\n')
                                        .replace(/\"/g, '\\"')
                                        .replace(/\'/g, "\\'")
                                        .replace(/[\u2019\u2019]/g, "\\'")
                                        .replace(/[\u201C\u201D]/g, '\\"');
  }
  
  // Collect all the nested definitions and remove them from input array
  let nestedDefinitions = {
    'affected': { values: input.affected, props: {}, objectType: 'affected-product', createFunction: createAffectedProduct },
    'problem_types': { values: input.problem_types, props: {}, objectType: 'problem-type', createFunction: createProblemType },
    'impacts': { values: input.impacts, props: {}, objectType: 'impact-type', createFunction: createVulnerabilityImpact },
    'metrics': { values: input.metrics, props: {}, objectType: 'metrics', field: 'metrics', createFunction: createMetric },
    'timeline': { values: input.timeline, props: {}, objectType: 'timeline-entry', createFunction: createTimelineEntry },
    'credits': { values: input.credits, props: {}, objectType: 'credit', createFunction: createCredit },
    'source': { values: input.source, props: {}, objectType: 'vulnerability-source', createFunction: createVulnerabilitySource },
    'taxonomy_mappings': { values: input.taxonomy_mappings, props: {}, objectType: 'taxonomy-map-entry', createFunction: createTaxonomyEntry },
    'references': { values: input.references, props: {}, objectType: 'vulnerability-reference', createFunction: createReference },
    'external_references': { values: input.external_references, props: {}, objectType: 'external-reference', createFunction: createExternalReference },
  };
  // Populate the set of nested definitions and clean up the input args
  nestedDefinitions = populateNestedDefinitions(nestedDefinitions);
  for (let fieldName of Object.keys(nestedDefinitions)) {
    if (input[fieldName]) delete input[fieldName];
  }

  // TODO: check if there are any references to other objects

  // create vulnerability
  let response;
  let {iri, id, query} = insertVulnerabilityQuery(input);
  try {
    response = await dataSources.Stardog.create({
      dbName: dbName,
      sparqlQuery: query,
      queryId: "Create Vulnerability object"
      });
  } catch (e) {
    logApp.error(e);
    throw e
  }

  // Attach any nest definitions
  await processNestedDefinitions(id, nestedDefinitions, dbName, dataSources, attachToVulnerabilityQuery);

  // TODO: Attach any references to other objects

  // retrieve the newly created Vulnerability to be returned
  let selectQuery = selectVulnerabilityQuery(id, select);
  let result;
    try {
    result = await dataSources.Stardog.queryById({
      dbName: dbName,
      sparqlQuery: selectQuery,
      queryId: "Select Vulnerability object",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    logApp.error(e);
    throw e
  }
  if (result === undefined || result === null || result.length === 0) return null;
  const reducer = getReducer("VULNERABILITY");
  return reducer(result[0]); 
};

export const deleteVulnerabilityById = async ( id, dbName, dataSources ) => {
  let removedIds = [];
  let idArray = [];
  let iri = null;

  if (!Array.isArray(id)) {
    idArray = [id];
  } else {
    idArray = id;
  }

  for (let itemId of idArray) {
    if (!checkIfValidUUID(itemId)) throw new UserInputError(`Invalid identifier: ${itemId}`, {identifier: `${itemId}`});
    iri = await deleteVulnerabilityByIri(getVulnerabilityIri(itemId),  dbName, dataSources);
    if (iri) {
      removedIds.push(itemId)
    } else {
      if (!Array.isArray(id)) throw new UserInputError(`Entity does not exist with id value ${id}`);
    }
  }
  
  if (!Array.isArray(id)) return id;
  return removedIds;
};

export const deleteVulnerabilityByIri = async ( iri, dbName, dataSources ) => {
  let select = ['iri','id','metrics','affected','impacts','problem_types','taxonomy_mappings','credits','references'];
  let response;
  
  // check if object with iri exists
  let sparqlQuery = selectVulnerabilityByIriQuery(iri, select);
  try {
    response = await dataSources.Stardog.queryById({
      dbName,
      sparqlQuery,
      queryId: "Select Vulnerability object",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    logApp.error(e);
    throw e
  }
    
  if (response === undefined || response.length === 0) {
    logApp.warn(`[CYIO] RESOURCE_NOT_FOUND_ERROR: Entity does not exist with iri ${iri}`);
    return null;
  }

  let vul = response[0];

  // define all the types of objects that are private to the vulnerability and need to be deleted
  let nestedObjects = {
    'affected': { object_type: 'affected', iris: vul.affected, deleteFunction: deleteAffectedProductByIri },
    'problem_types': { object_type: 'problem_types', iris: vul.problem_types, deleteFunction: deleteProblemTypeByIri },
    'impacts': { object_type: 'impacts', iris: vul.impacts, deleteFunction: deleteVulnerabilityImpactByIri },
    'metrics': { object_type: 'metrics', iris: vul.metrics, deleteFunction: deleteMetricByIri },
    'timeline': { object_type: 'timeline-entry', iris: vul.timeline, deleteFunction: deleteTimelineEntryByIri },
    'credits': { object_type: 'credits', iris: vul.credits, deleteFunction: deleteCreditByIri },
    'source': { object_type: 'source', iris: vul.source, deleteFunction: deleteVulnerabilitySourceByIri },
    'taxonomy_mappings': { object_type: 'taxonomy_mappings', iris: vul.taxonomy_mappings, deleteFunction: deleteTaxonomyEntryByIri },
    'references': { object_type: 'vulnerability-reference', iris: vul.references, deleteFunction: deleteReferenceByIri },
    'external_references': { object_type: 'external-reference', iris: vul.external_references, deleteFunction: deleteExternalReferenceByIri },
  };

  // delete any nested nodes
  for (let [fieldName, fieldInfo] of Object.entries(nestedObjects)) {
    if (fieldInfo.iris === undefined || fieldInfo.iris === null) continue;
    if (!Array.isArray(fieldInfo.iris)) fieldInfo.iris = [fieldInfo.iris];
    for( let iri of fieldInfo.iris) {
      let result = await fieldInfo.deleteFunction( iri, dbName, dataSources);
    }
  }
  
  // Delete the vulnerability
  try {
    sparqlQuery = deleteVulnerabilityByIriQuery(iri);
    response = await dataSources.Stardog.delete({
      dbName,
      sparqlQuery,
      queryId: "Delete Vulnerability"
    });
  } catch (e) {
    logApp.error(e);
    throw e
  }

  return iri;
};

export const editVulnerabilityById = async (id, input, dbName, dataSources, select, schema) => {
  if (!checkIfValidUUID(id)) throw new UserInputError(`Invalid identifier: ${id}`, {identifier: `${id}`});  

  // make sure there is input data containing what is to be edited
  if (input === undefined || input.length === 0) throw new UserInputError(`No input data was supplied`);

  // WORKAROUND to remove immutable fields
  input = input.filter(element => (element.key !== 'id' && element.key !== 'created' && element.key !== 'modified'));

  // check that the object to be edited exists with the predicates - only get the minimum of data
  let editSelect = ['id','created','modified'];
  for (let editItem of input) {
    editSelect.push(editItem.key);
  }

  const sparqlQuery = selectVulnerabilityQuery(id, editSelect );
  let response = await dataSources.Stardog.queryById({
    dbName,
    sparqlQuery,
    queryId: "Select Vulnerability",
    singularizeSchema: singularizeVulnerabilitySchema
  });

  if (response.length === 0) throw new UserInputError(`Entity does not exist with ID ${id}`, {identifier: `${id}`});

  // determine operation, if missing
  for (let editItem of input) {
    if (editItem.operation !== undefined) continue;

    // if value if empty then treat as a remove
    if (editItem.value.length === 0) { 
      editItem.operation = 'remove';
      continue;
    }
    if (Array.isArray(editItem.value) && editItem.value[0] === null) throw new UserInputError(`Field "${editItem.key}" has invalid value "null"`, {field: `${editItem.key}`});

    if (!response[0].hasOwnProperty(editItem.key)) {
      editItem.operation = 'add';
    } else {
      editItem.operation = 'replace';

      // Set operation to 'skip' if no change in value
      if (response[0][editItem.key] === editItem.value) editItem.operation ='skip';
    }
  }

  // Push an edit to update the modified time of the object
  const timestamp = new Date().toISOString();
  if (!response[0].hasOwnProperty('created')) {
    let update = {key: "created", value:[`${timestamp}`], operation: "add"}
    input.push(update);
  }

  let operation = "replace";
  if (!response[0].hasOwnProperty('modified')) operation = "add";
  let update = {key: "modified", value:[`${timestamp}`], operation: `${operation}`}
  input.push(update);
  
  // Handle the update to fields that have references to other object instances
  for (let editItem  of input) {
    if (editItem.operation === 'skip') continue;

    let value, fieldType, objectType, objArray, iris=[];
    for (value of editItem.value) {
      switch(editItem.key) {
        case 'cna_tags':
          if (!validateEnumValue(value, 'CNATag', schema)) throw new UserInputError(`Invalid value "${value}" for field "${editItem.key}".`);
          editItem.value[0] = value.replace(/_/g,'-').toLowerCase();
          fieldType = 'simple';
          break;
        case 'state':
          if (!validateEnumValue(value, 'VulnerabilityState', schema)) throw new UserInputError(`Invalid value "${value}" for field "${editItem.key}".`);
          editItem.value[0] = value.replace(/_/g,'-').toLowerCase();
          fieldType = 'simple';
          break;
        case 'labels':
          objectType = 'label';
          fieldType = 'id';
          break;
        case 'links':
          objectType = 'external-reference';
          fieldType = 'id';
          break;
        case 'notes':
          objectType = 'note';
          fieldType = 'id';
          break;
        case 'metrics':
        case 'affected':
        case 'impacts':
        case 'problem_types':
        case 'credits':
        case 'taxonomy_mappings':
        case 'timeline':
        case 'source':
        case 'references':
          throw new UserInputError(`Cannot directly edit field "${editItem.key}".`);
        default:
          fieldType = 'simple';
          break;
      }

      if (fieldType === 'id') {
        // continue to next item if nothing to do
        if (editItem.operation === 'skip') continue;

        let sparqlQuery = selectObjectIriByIdQuery(value, objectType);
        let result = await dataSources.Stardog.queryById({
          dbName,
          sparqlQuery,
          queryId: "Obtaining IRI for the object with id",
          singularizeSchema: singularizeVulnerabilitySchema
        });

        if (result === undefined || result.length === 0) throw new UserInputError(`Entity does not exist with ID ${value}`, {identifier: `${value}`});
        iris.push(`<${result[0].iri}>`);
      }
    }
    if (iris.length > 0) editItem.value = iris;
  }

  const query = updateQuery(
    getVulnerabilityIri(id),
    "http://nist.gov/ns/vulnerability#Vulnerability",
    input,
    vulnerabilityPredicateMap
  );

  if (query !== null) {
    let response;
    try {
      response = await dataSources.Stardog.edit({
        dbName,
        sparqlQuery: query,
        queryId: "Update Vulnerability"
      });  
    } catch (e) {
      logApp.error(e);
      throw e
    }
  }

  let result;
  try {
    const selectQuery = selectVulnerabilityQuery(id, select);
    result = await dataSources.Stardog.queryById({
      dbName,
      sparqlQuery: selectQuery,
      queryId: "Select Vulnerability",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    logApp.error(e);
    throw e;
  }

  const reducer = getReducer("VULNERABILITY");
  return reducer(result[0]);
};

export const attachToVulnerability = async (id, field, entityId, dbName, dataSources) => {
  if (!checkIfValidUUID(id)) throw new UserInputError(`Invalid identifier: ${id}`, {identifier: `${id}`});
  if (!checkIfValidUUID(entityId)) throw new UserInputError(`Invalid identifier: ${entityId}`, {identifier: `${entityId}`});

  // check to see if the vulnerability exists
  let sparqlQuery;
  let select = ['id','iri','object_type'];
  let iri = getVulnerabilityIri(id);

  let response;
  try {
    sparqlQuery = selectVulnerabilityByIriQuery(iri, select);
    response = await dataSources.Stardog.queryById({
      dbName,
      sparqlQuery,
      queryId: "Select Vulnerability",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    logApp.error(e);
    throw e
  }
  if (response === undefined || response === null || response.length === 0) throw new UserInputError(`Entity does not exist with ID ${id}`, {identifier: `${id}`});

  let attachableObjects = {
    'metrics': 'cvss',
    'affected': 'affected-product',
    'impacts': 'impact-type',
    'problem_types': 'problem-type',
    'taxonomy_mappings': 'taxonomy-map-entry',
    'credits': 'credit',
    'timeline': 'timeline-entry',
    'source': 'vulnerability-source',
    'references': 'vulnerability-reference',
  };

  let objectType = attachableObjects[field];
  try {
    // check to see if the entity exists
    sparqlQuery = selectObjectIriByIdQuery(entityId, objectType);
    response = await dataSources.Stardog.queryById({
      dbName: (objectType === 'marking-definition' ? conf.get('app:config:db_name') || 'cyio-config' : dbName),
      sparqlQuery,
      queryId: "Obtaining IRI for the object with id",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    logApp.error(e);
    throw e
  }
  if (response === undefined || response === null || response.length === 0) throw new UserInputError(`Entity does not exist with ID ${entityId}`, {identifier: `${entityId}`});

  let objectTypeMapping = {
    'metrics': [
      'cvss-v2',
      'cvss-v3',
      'cvss-v4'
    ],
    'affected': 'affected-product',
    'impacts': 'impact-type',
    'problem_types': 'problem-type',
    'taxonomy_mappings': 'taxonomy-map-entry',
    'credits': 'credit',
    'timeline': 'timeline-entry',
    'source': 'vulnerability-source',
    'references': 'vulnerability-reference',
  };
  
  // check to make sure entity to be attached is proper for the field specified
  if (field == 'metrics') {
    if (!objectTypeMapping[field].includes(response[0].object_type)) {
      throw new UserInputError(`Can not attach object of type '${response[0].object_type}' to field '${field}'`);
    }
  } else {
    if (response[0].object_type !== attachableObjects[field]) {
      if (!objectTypeMapping.hasOwnProperty(response[0].object_type)) throw new UserInputError(`Can not attach object of type '${response[0].object_type}' to field '${field}'`);
    }
  }

  // retrieve the IRI of the entity
  let entityIri = `<${response[0].iri}>`;

  // Attach the object to the vulnerability
  sparqlQuery = attachToVulnerabilityQuery(id, field, entityIri);
  try {
    response = await dataSources.Stardog.create({
      dbName,
      sparqlQuery,
      queryId: `Attach ${field} to Vulnerability`
      });
  } catch (e) {
    logApp.error(e);
    throw e
  }

  return true;
};

export const detachFromVulnerability = async (id, field, entityId, dbName, dataSources) => {
  if (!checkIfValidUUID(id)) throw new UserInputError(`Invalid identifier: ${id}`, {identifier: `${id}`});
  if (!checkIfValidUUID(entityId)) throw new UserInputError(`Invalid identifier: ${entityId}`, {identifier: `${entityId}`});

  let sparqlQuery;

  // check to see if the vulnerability exists
  let select = ['id','iri','object_type'];
  let iri = getVulnerabilityIri(id);
  let response;
  try {
    sparqlQuery = selectVulnerabilityByIriQuery(iri, select);
    response = await dataSources.Stardog.queryById({
      dbName,
      sparqlQuery,
      queryId: "Select Vulnerability",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    logApp.error(e);
    throw e
  }
  if (response === undefined || response === null || response.length === 0) throw new UserInputError(`Entity does not exist with ID ${id}`, {identifier: `${id}`});

  let attachableObjects = {
    'metrics': 'cvss',
    'affected': 'affected-product',
    'impacts': 'impact-type',
    'problem_types': 'problem-type',
    'taxonomy_mappings': 'taxonomy-map-entry',
    'credits': 'credit',
    'timeline': 'timeline-entry',
    'source': 'vulnerability-source',
    'references': 'vulnerability-reference',
  };

  let objectType = attachableObjects[field];
  try {
    // check to see if the entity exists
    sparqlQuery = selectObjectIriByIdQuery(entityId, objectType);
    response = await dataSources.Stardog.queryById({
      dbName: (objectType === 'marking-definition' ? conf.get('app:config:db_name') || 'cyio-config' : dbName),
      sparqlQuery,
      queryId: "Obtaining IRI for the object with id",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    logApp.error(e);
    throw e
  }
  if (response === undefined || response === null || response.length === 0) throw new UserInputError(`Entity does not exist with ID ${entityId}`, {identifier: `${entityId}`});

  let objectTypeMapping = {
    'metrics': [
      'cvss-v2',
      'cvss-v3',
      'cvss-v4'
    ],
    'affected': 'affected-product',
    'impacts': 'impact-type',
    'problem_types': 'problem-type',
    'taxonomy_mappings': 'taxonomy-map-entry',
    'credits': 'credit',
    'timeline': 'timeline-entry',
    'source': 'vulnerability-source',
    'references': 'vulnerability-reference',
  };

  // check to make sure entity to be attached is proper for the field specified
  if (field == 'metrics') {
    if (!objectTypeMapping[field].includes(response[0].object_type)) {
      throw new UserInputError(`Can not attach object of type '${response[0].object_type}' to field '${field}'`);
    }
  } else {
    if (response[0].object_type !== attachableObjects[field]) {
      if (!objectTypeMapping.hasOwnProperty(response[0].object_type)) throw new UserInputError(`Can not attach object of type '${response[0].object_type}' to field '${field}'`);
    }
  }

  // retrieve the IRI of the entity
  let entityIri = `<${response[0].iri}>`;

  // Attach the object to the Vulnerability
  try {
    sparqlQuery = detachFromVulnerabilityQuery(id, field, entityIri);
    response = await dataSources.Stardog.create({
      dbName,
      sparqlQuery,
      queryId: `Detach ${field} from Vulnerability`
      });
  } catch (e) {
    logApp.error(e);
    throw e
  }

  return true;
};
