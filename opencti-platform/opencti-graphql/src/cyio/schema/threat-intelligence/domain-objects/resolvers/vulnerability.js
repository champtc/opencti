import { logApp } from '../../../../../config/conf.js';
import {
  findAllVulnerabilities,
  findVulnerabilityById,
  createVulnerability,
  deleteVulnerabilityById,
  editVulnerabilityById,
  attachToVulnerability,
  detachFromVulnerability,
} from '../domain/vulnerability.js';
import { findAffectedProductByIri, findAllAffectedProducts } from '../domain/affectedProduct.js';
import { findCreditByIri } from '../domain/credit.js';
import { findProblemTypeByIri, findAllProblemTypes } from '../domain/problemType.js';
import { findAllReferences } from '../domain/reference.js';
import { findMetricByIri, findAllMetrics } from '../domain/metric.js';
import { findTaxonomyEntryByIri, findAllTaxonomyEntries } from '../domain/taxonomyEntry.js';
import { findTimelineEntryByIri, findAllTimelineEntries } from '../../domain-objects/domain/timelineEntry.js';
import { findVulnerabilityImpactByIri, findAllVulnerabilityImpacts } from '../domain/vulnerabilityImpact.js';
import { findVulnerabilitySourceByIri, findAllVulnerabilitySources } from '../../domain-objects/domain/vulnerabilitySource.js';
import { findDataMarkingByIri, findAllDataMarkings } from '../../../data-markings/domain/dataMarkings.js';
import { findLabelByIri } from '../../../global/domain/label.js';
import { findExternalReferenceByIri } from '../../../global/domain/externalReference.js';
import { findNoteByIri } from '../../../global/domain/note.js';


const cyioVulnerabilityResolvers = {
  Query: {
      vulnerabilities: async (_, args, { dbName, dataSources, selectMap }) => findAllVulnerabilities(_, args, dbName, dataSources, selectMap.getNode('node')),
      vulnerability: async (_, { id }, { dbName, dataSources, selectMap }) => findVulnerabilityById(id, dbName, dataSources, selectMap.getNode('vulnerability')),
  },
  Mutation: {
      createVulnerability: async (_, { input }, { dbName, selectMap, dataSources }) => createVulnerability(input, dbName, dataSources, selectMap.getNode("createVulnerability")),
      deleteVulnerability: async (_, { id }, { dbName, dataSources }) => deleteVulnerabilityById(id, dbName, dataSources),
      deleteVulnerabilities: async (_, { ids }, { dbName, dataSources }) => deleteVulnerabilityById(ids, dbName, dataSources),
      editVulnerability: async (_, { id, input }, { dbName, dataSources, selectMap }, {schema}) => editVulnerabilityById(id, input, dbName, dataSources, selectMap.getNode("editVulnerability"), schema),
      attachToVulnerability: async (_, { id, field, entityId }, { dbName, dataSources }) => attachToVulnerability(id, field, entityId, dbName, dataSources),
      detachFromVulnerability: async (_, { id, field, entityId }, { dbName, dataSources }) => detachFromVulnerability(id, field, entityId, dbName, dataSources),
  },
  Vulnerability : {
    affected: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.affected_iris === undefined) return [];
      let args = {'orderBy': 'display_name', 'orderMode':'asc'}
      let connection = await findAllAffectedProducts(parent, args, dbName, dataSources, selectMap.getNode('node'));
      let results = [];
      if (connection !== null) {
        for (let edge of connection.edges) results.push(edge.node);
      }
      return results;
    },
    credits: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.credit_iris === undefined) return [];
      let args = {'orderBy': 'display_name', 'orderMode':'asc'}
      let connection = await findAllCredits(parent, args, dbName, dataSources, selectMap.getNode('node'));
      let results = [];
      if (connection !== null) {
        for (let edge of connection.edges) results.push(edge.node);
      }
      return results;
    },
    impacts: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.impact_iris === undefined) return [];
      let connection = await findAllVulnerabilityImpacts(parent, _, dbName, dataSources, selectMap.getNode('node'));
      let results = [];
      if (connection !== null) {
        for (let edge of connection.edges) results.push(edge.node);
      }
      return results;
    },
    metrics: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.metric_iris === undefined) return [];
      let args = {'orderBy': 'format', 'orderMode':'asc'}
      let connection = await findAllMetrics(parent, args, dbName, dataSources, selectMap.getNode('node'));
      let results = [];
      if (connection !== null) {
        for (let edge of connection.edges) results.push(edge.node);
      }
      return results;
    },
    problem_types: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.problem_type_iris === undefined) return [];
      let connection = await findAllProblemTypes(parent, _, dbName, dataSources, selectMap.getNode('node'));
      let results = [];
      if (connection !== null) {
        for (let edge of connection.edges) results.push(edge.node);
      }
      return results;
    },
    references: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.reference_iris === undefined) return [];
      let connection = await findAllReferences(parent, _, dbName, dataSources, selectMap.getNode('node'));
      let results = [];
      if (connection !== null) {
        for (let edge of connection.edges) results.push(edge.node);
      }
      return results;
    },
    source: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.source_iris === undefined) return [];
      let connection = await findAllVulnerabilitySources(parent, _, dbName, dataSources, selectMap.getNode('node'));
      let results = [];
      if (connection !== null) {
        for (let edge of connection.edges) results.push(edge.node);
      }
      return results;
    },
    taxonomy_mappings: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.taxonomy_mappings === undefined) return [];
      let args = {'orderBy': 'display_name', 'orderMode':'asc'}
      let connection = await findAllTaxonomyEntries(parent, args, dbName, dataSources, selectMap.getNode('node'));
      let results = [];
      if (connection !== null) {
        for (let edge of connection.edges) results.push(edge.node);
      }
      return results;
    },
    timeline: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.timeline_iris === undefined) return [];
      let args = {'orderBy': 'timestamp', 'orderMode':'asc'}
      let connection = await findAllTimelineEntries(parent, args, dbName, dataSources, selectMap.getNode('node'));
      let results = [];
      if (connection !== null) {
        for (let edge of connection.edges) results.push(edge.node);
      }
      return results;
    },
    object_markings: async (parent, _, { dbName, dataSources, selectMap}) => {
      if (parent.marking_iris === undefined) return [];
      let connection = await findAllDataMarkings(parent, _, dbName, dataSources, selectMap.getNode('node'));
      let results = [];
      if (connection !== null) {
        for (let edge of connection.edges) results.push(edge.node);
      }
      return results;
    },
    labels: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.label_iris === undefined) return [];
      let results = []
      for (let iri of parent.label_iris) {
        let result = await findLabelByIri(iri, dbName, dataSources, selectMap.getNode('labels'));
        if (result === undefined || result === null) {
          logApp.warn(`[CYIO] RESOURCE_NOT_FOUND_ERROR: Cannot retrieve Labels resource ${iri}`);
          continue;
        }
        results.push(result);
      }
      return results;
    },
    external_references: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.external_reference_iris === undefined) return [];
      let results = []
      for (let iri of parent.external_reference_iris) {
        let result = await findExternalReferenceByIri(iri, dbName, dataSources, selectMap.getNode('external_references'));
        if (result === undefined || result === null) {
          logApp.warn(`[CYIO] RESOURCE_NOT_FOUND_ERROR: Cannot retrieve ExternalReferences resource ${iri}`);
          continue;
        }
        results.push(result);
      }
      return results;
    },
    notes: async (parent, _, { dbName, dataSources, selectMap }) => {
      if (parent.note_iris === undefined) return [];
      let results = []
      for (let iri of parent.note_iris) {
        let result = await findNoteByIri(iri, dbName, dataSources, selectMap.getNode('notes'));
        if (result === undefined || result === null) {
          logApp.warn(`[CYIO] RESOURCE_NOT_FOUND_ERROR: Cannot retrieve Notes resource ${iri}`);
          continue;
        }
        results.push(result);
      }
      return results;
    },
  },
  // Map GraphQL enum values to data model required values
  CNATag: {
    unsupported_when_assigned: 'unsupported-when-assigned',
    exclusively_hosted_service: 'exclusively-hosted-service',
    disputed: 'disputed',
  },
  CreditType: {
    finder: 'finder',
    reporter: 'reporter',
    analyst: 'analyst',
    coordinator: 'coordinator',
    remediation_developer: 'remediation developer',
    remediation_reviewer: 'remediation reviewer',
    remediation_verifier: 'remediation verifier',
    tool: 'tool',
    sponsor: 'sponsor',
    other: 'other',
  }
};

export default cyioVulnerabilityResolvers;
