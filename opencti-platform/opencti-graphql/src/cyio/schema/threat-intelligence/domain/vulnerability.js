import { UserInputError } from 'apollo-server-errors';
import conf from '../../../../config/conf';
import { compareValues, filterValues, updateQuery, checkIfValidUUID, validateEnumValue } from '../../utils.js';
import { selectObjectIriByIdQuery } from '../../global/global-utils.js';
import {
  insertVulnerabilityQuery,
  selectVulnerabilityQuery,
  singularizeVulnerabilitySchema,
  selectAllVulnerabilitiesQuery,
  selectVulnerabilityQueryByIriQuery,
  attachToVulnerabilityQuery,
  detachFromVulnerabilityQuery,
  getReducer
} from '../schema/sparql/vulnerability.js';

export const createVulnerability = async (input, dbName, dataSources, select) => {
  // Need to escape contents, remove explicit newlines, and collapse multiple what spaces.
  if (input.title !== undefined ) {
    input.title = input.title.replace(/\s+/g, ' ')
      .replace(/\n/g, '\\n')
      .replace(/\"/g, '\\"')
      .replace(/\'/g, "\\'")
      .replace(/[\u2019\u2019]/g, "\\'")
      .replace(/[\u201C\u201D]/g, '\\"');
  }

  if (input.description !== undefined ) {
    input.description = input.description.replace(/\s+/g, ' ')
      .replace(/\n/g, '\\n')
      .replace(/\"/g, '\\"')
      .replace(/\'/g, "\\'")
      .replace(/[\u2019\u2019]/g, "\\'")
      .replace(/[\u201C\u201D]/g, '\\"');
  }

  // create vulnerabilitiy
  let response;
  let {iri, id, query} = insertVulnerabilityQuery(input);

  try {
    response = await dataSources.Stardog.create({
      dbName: dbName,
      sparqlQuery: query,
      queryId: "Create Vulnerability object"
      });
  } catch (e) {
    console.log(e)
    throw e
  }

  // retrieve the newly created Vulnerability to be returned
  const selectQuery = selectVulnerabilityQuery(id, select);
  let result;
  
  try {
    result = await dataSources.Stardog.queryById({
      dbName: dbName,
      sparqlQuery: selectQuery,
      queryId: "Select Vulnerability object",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    console.log(e)
    throw e
  }

  if (result === undefined || result === null || result.length === 0) return null;
  
  const reducer = getReducer("VULNERABILITY");
  return reducer(result[0]); 
};

export const findVulnerabilityById = async (id, dbName, dataSources, select) => {
  // ensure the id is a valid UUID
  if (!checkIfValidUUID(id)) throw new UserInputError(`Invalid identifier: ${id}`);

  // retrieve the newly created Vulnerability to be returned
  const selectQuery = selectVulnerabilityQuery(id, select);
  let result;
  try {
    result = await dataSources.Stardog.queryById({
      dbName: dbName,
      sparqlQuery: selectQuery,
      queryId: "Select Vulnerability object",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    console.log(e)
    throw e
  }
  if (result === undefined || result === null || result.length === 0) return null;
  const reducer = getReducer("VULNERABILITY");
  return reducer(result[0]);
};

export const findAllVulnerabilities = async ( args, dbName, dataSources, select ) => {
  const sparqlQuery = selectAllVulnerabilitiesQuery(select, args);
  let response;
  try {
    response = await dataSources.Stardog.queryAll({
      dbName: dbName,
      sparqlQuery,
      queryId: "Select List of Vulnerabilities",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    console.log(e)
    throw e
  }

  // no results found
  if (response === undefined || response.length === 0) return null;

  // if no matching results, then return null
  if (Array.isArray(response) && response.length < 1) return null;

  const edges = [];
  const reducer = getReducer("VULNERABILITY");
  let skipCount = 0,filterCount = 0, resultCount = 0, limit, offset, limitSize, offsetSize;
  limitSize = limit = (args.first === undefined ? response.length : args.first) ;
  offsetSize = offset = (args.offset === undefined ? 0 : args.offset) ;

  let resultList ;
  if (args.orderedBy !== undefined ) {
    resultList = response.sort(compareValues(args.orderedBy, args.orderMode ));
  } else {
    resultList = response;
  }

  // return null if offset value beyond number of results items
  if (offset > resultList.length) return null;

  // for each result in the result set
  for (let resultItem of resultList) {
    // skip down past the offset
    if (offset) {
      offset--
      continue
    }

    // filter out non-matching entries if a filter is to be applied
    if ('filters' in args && args.filters != null && args.filters.length > 0) {
      if (!filterValues(resultItem, args.filters, args.filterMode) ) {
        continue
      }
      filterCount++;
    }

    // if haven't reached limit to be returned
    if (limit) {
      let edge = {
        cursor: resultItem.iri,
        node: reducer(resultItem),
      }
      edges.push(edge)
      limit--;
      if (limit === 0) break;
    }
  }
  // check if there is data to be returned
  if (edges.length === 0 ) return null;
  let hasNextPage = false, hasPreviousPage = false;
  resultCount = resultList.length - skipCount;
  if (edges.length < resultCount) {
    if (edges.length === limitSize && filterCount <= limitSize ) {
      hasNextPage = true;
      if (offsetSize > 0) hasPreviousPage = true;
    }
    if (edges.length <= limitSize) {
      if (filterCount !== edges.length) hasNextPage = true;
      if (filterCount > 0 && offsetSize > 0) hasPreviousPage = true;
    }
  }
  return {
    pageInfo: {
      startCursor: edges[0].cursor,
      endCursor: edges[edges.length-1].cursor,
      hasNextPage: (hasNextPage ),
      hasPreviousPage: (hasPreviousPage),
      globalCount: resultCount,
    },
    edges: edges,
  }
};

export const deleteVulnerabilityById = async ( id, dbName, dataSources, select ) => {
  /* let select = ['iri','id','source','credits','timeline', 'impacts'];
  let idArray = [];

  if (!Array.isArray(id)) {
    idArray = [id];
  } else {
    idArray = id;
  }

  let removedIds = []

  for (let itemId of idArray) {
    let response;

    if (!checkIfValidUUID(itemId)) throw new UserInputError(`Invalid identifier: ${itemId}`);  

    // check if object with id exists
    let sparqlQuery = selectInformationSystemQuery(itemId, select);
    try {
      response = await dataSources.Stardog.queryById({
        dbName,
        sparqlQuery,
        queryId: "Select Information System",
        singularizeSchema: singularizeInformationSystemSchema
      });
    } catch (e) {
      console.log(e)
      throw e
    }
    
    if (response === undefined || response.length === 0) throw new UserInputError(`Entity does not exist with ID ${itemId}`);
    let infoSys = response[0];

    // Removing Information System Asset from Asset Inventory
    const invQuery = removeFromInventoryQuery(infoSys.iri);
    await dataSources.Stardog.create({
      dbName,
      sparqlQuery: invQuery,
      queryId: 'Removing Information System Asset from Inventory',
    });

    let nestedReferences = {
      'authorization_boundary': { iris: infoSys.authorization_boundary, deleteFunction: deleteDescriptionBlockByIri},
      'network_architecture': { iris: infoSys.network_architecture, deleteFunction: deleteDescriptionBlockByIri},
      'data_flow': { iris: infoSys.data_flow, deleteFunction: deleteDescriptionBlockByIri }
    };
    // delete any nested nodes that are private to the information system
    for (let [fieldName, fieldInfo] of Object.entries(nestedReferences)) {
      if (fieldInfo.iris === undefined || fieldInfo.iris === null) continue;
      if (!Array.isArray(fieldInfo.iris)) fieldInfo.iris = [fieldInfo.iris];
      for( let descBlockIri of fieldInfo.iris) {
        let result = await deleteDescriptionBlockByIri(descBlockIri, dbName, dataSources);
      }
    }
  
    sparqlQuery = deleteInformationSystemQuery(itemId);
    
    try {
      response = await dataSources.Stardog.delete({
        dbName,
        sparqlQuery,
        queryId: "Delete Information System"
      });
    } catch (e) {
      console.log(e)
      throw e
    }
    
    removedIds.push(itemId);
  }

  if (!Array.isArray(id)) return id;
  return removedIds; */
};

export const deleteVulnerabilities = async ( args, dbName, dataSources, select ) => {

};

export const attachToVulnerability = async (id, field, entityId, dbName, dataSources) => {
  let sparqlQuery;
  if (!checkIfValidUUID(id)) throw new UserInputError(`Invalid identifier: ${id}`);
  if (!checkIfValidUUID(entityId)) throw new UserInputError(`Invalid identifier: ${entityId}`);

  // check to see if the vulnerability exists
  let select = ['id','iri','object_type'];
  let iri = `<http://cyio.darklight.ai/vulnerability--${id}>`;
  sparqlQuery = selectVulnerabilityQueryByIriQuery(iri, select);
  let response;
  try {
    response = await dataSources.Stardog.queryById({
      dbName,
      sparqlQuery,
      queryId: "Select Vulnerability",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    console.log(e)
    throw e
  }
  if (response === undefined || response === null || response.length === 0) throw new UserInputError(`Entity does not exist with ID ${id}`);

  let attachableObjects = {
    'affected_products': 'affected-product', 
    'credits': 'credit', 
    'impacts': 'impact-type', 
    'metrics': 'metric-type', 
    'problem_types': 'problem-type', 
    'source': 'vulnerability-source', 
    'taxonomy_mappings': 'taxonomy-map-entry',
    // common attachable fields
    'timeline': 'timeline-entry',
    'labels': 'label', 
    'external_references': 'external-reference', 
    'notes': 'note', 
    'object_markings': 'marking-definition'
  }

  let objectType = attachableObjects[field];
  try {
    // check to see if the entity exists
    sparqlQuery = selectObjectIriByIdQuery(entityId, objectType);
    response = await dataSources.Stardog.queryById({
      dbName: (objectType === 'marking-definition' ? conf.get('app:config:db_name') || 'cyio-config' : dbName),
      sparqlQuery,
      queryId: "Obtaining IRI for the object with id",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    console.log(e)
    throw e
  }
  if (response === undefined || response === null || response.length === 0) throw new UserInputError(`Entity does not exist with ID ${entityId}`);
  
  // check to make sure entity to be attached is proper for the field specified
  if (response[0].object_type !== attachableObjects[field]) {
    if (!objectTypeMapping.hasOwnProperty(response[0].object_type)) throw new UserInputError(`Can not attach object of type '${response[0].object_type}' to field '${field}'`);
  }

  // retrieve the IRI of the entity
  let entityIri = `<${response[0].iri}>`;

  // Attach the object to the information system
  sparqlQuery = attachToVulnerabilityQuery(id, field, entityIri);
  try {
    response = await dataSources.Stardog.create({
      dbName,
      sparqlQuery,
      queryId: `Attach ${field} to Vulnerability`
      });
  } catch (e) {
    console.log(e)
    throw e
  }

  return true;
};

export const detachFromVulnerability = async (id, field, entityId, dbName, dataSources) => {
  let sparqlQuery;
  if (!checkIfValidUUID(id)) throw new UserInputError(`Invalid identifier: ${id}`);
  if (!checkIfValidUUID(entityId)) throw new UserInputError(`Invalid identifier: ${entityId}`);

  // check to see if the vulnerability exists

  let select = ['id','iri','object_type'];
  let iri = `<http://cyio.darklight.ai/vulnerability--${id}>`;
  sparqlQuery = selectVulnerabilityQueryByIriQuery(iri, select);
  
  let response;
  try {
    response = await dataSources.Stardog.queryById({
      dbName,
      sparqlQuery,
      queryId: "Select Vulnerability",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    console.log(e)
    throw e
  }
  if (response === undefined || response === null || response.length === 0) throw new UserInputError(`Entity does not exist with ID ${id}`);

  let attachableObjects = {
    'affected_products': 'affected-product', 
    'credits': 'credit', 
    'impacts': 'impact-type', 
    'metrics': 'metric-type', 
    'problem_types': 'problem-type', 
    'source': 'vulnerability-source', 
    'taxonomy_mappings': 'taxonomy-map-entry',
    'timeline': 'timeline-entry',
    'labels': 'label', 
    'external_references': 'external-reference', 
    'notes': 'note', 
    'object_markings': 'marking-definition'
  }

  let objectType = attachableObjects[field];
  
  try {
    // check to see if the entity exists
    sparqlQuery = selectObjectIriByIdQuery(entityId, objectType);
    response = await dataSources.Stardog.queryById({
      dbName: (objectType === 'marking-definition' ? conf.get('app:config:db_name') || 'cyio-config' : dbName),
      sparqlQuery,
      queryId: "Obtaining IRI for the object with id",
      singularizeSchema: singularizeVulnerabilitySchema
    });
  } catch (e) {
    console.log(e)
    throw e
  }

  if (response === undefined || response === null || response.length === 0) throw new UserInputError(`Entity does not exist with ID ${entityId}`);

  // check to make sure entity to be attached is proper for the field specified
  if (response[0].object_type !== attachableObjects[field]) {
    if (!objectTypeMapping.hasOwnProperty(response[0].object_type)) throw new UserInputError(`Can not attach object of type '${response[0].object_type}' to field '${field}'`);
  }

  // retrieve the IRI of the entity
  let entityIri = `<${response[0].iri}>`;

  // Attach the object to the information system
  sparqlQuery = detachFromVulnerabilityQuery(id, field, entityIri);
  try {
    response = await dataSources.Stardog.create({
      dbName,
      sparqlQuery,
      queryId: `Detach ${field} from Vulnerability`
      });
  } catch (e) {
    console.log(e)
    throw e
  }

  return true;
};
